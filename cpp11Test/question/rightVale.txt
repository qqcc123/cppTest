///------------------c++ 的完美转发是怎么做的？------------------------------------

C++的完美转发是采用泛型函数与 Rvalue 引用特性，将参数类型与其 constness、volatility 甚至它的引用性（可能是左值引用或右值引用）都完美的转发到另一个函数。


在具体操作中，我们主要借助"std::forward"这个函数模板的特性。


例如我们定义一个函数模板print:


template <typename T>
void print(T&& t){
    std::cout << t << std::endl;
}

然后再定义一个forward函数模板来接收参数，通过print输出：


template <typename T>
void forward(T&& t){
    print(std::forward<T>(t));
}

在这里，std::forward<T>(t) 就完成了对参数 t 的完美转发。因为完美转发能保存原参数 t 的所有信息（包括是否为左值），所以可以将它完全正确的转发给另一个函数。


同时要注意，在泛型编程中，完美转发需要类型推导的过程，所以我们并不会直接使用T&& t来调用std::forward<T>，而是使用std::forward<T>(t)。因为并不是所有的 T&& 都可以表示右值引用。


///------------------类型推导是指的什么 ?------------------------------------
类型推导是 C++ 的一种机制，使得程序可以在某种程度上自动判断出表达式、变量或对象的类型。


类型推导常用的有三种情况：auto、decltype和模板，这三者都使用了编译时的类型推导。


1）auto 用于自动推导变量类型：


auto x = 4;    // x is int
auto y = 3.37; // y is double

2）decltype 用于获取表达式的数据类型:


int x = 0;
decltype(x) y = x; // y 的类型为 int

3）函数模板或类模板中的参数类型推导：


template<typename T>
void func(T a)
{
    cout << a << endl;
}

func(12); // 会自动推导出 T 是 int 类型。

在几乎所有的函数参数类型推导的情况中，如模板类型推导和auto类型推导，C++都会忽略顶层const，并且不会把传入的右值参数推导为一个具有完整类型的右值引用，只有在函数模板参数采用T&&这种形式，
才会保留参数的左值特性或者右值特性，这就是万能引用。右值引用就是我们在谈论完美转发时说的rvalue reference，一般用于实现移动语义和完美转发。

///------------------万能引用解释一下 ? ------------------------------------
在 C++ 中，我们常常听到一个术语叫做"万能引用"或者"通用引用"，这是一个非正式的术语，是针对 C++11 中新加入的右值引用特性提出来的。万能引用是指函数模板中的参数可以根据实际情况自动推导为左值引用或右值引用。


例如：


template<typename T>
void f(T&& param);```
在这个模板函数中，param 就是一个通用引用。

通用引用主要有以下特点：
1) 它只能出现在函数模板中，不能用在普通函数或类模板中。
2) 它的形式必须是 T&&，但并没有明确表示出是左值引用还是右值引用，会根据输入参数来进行推导。
3) 如果传给 f 的是左值（例如，一个变量或者 const 对象）, 那么 T 将被推导为一个左值引用类型，结果是 param 的类型为左值引用。 
4) 如果传给 f 的是右值，那么 T 将被推导为一个普通的非引用类型（例如 int），然后 param 的类型就是右值引用。

需要注意的是，对于万能引用，我们通常需要搭配 std::forward 一起使用，使得函数内部能够保持参数的原有的值类别（左值或右值）。


///------------------std::forward 内部实现 ------------------------------------
std::forward是C++标准库中的一个模板函数，它用于将参数按照原类型进行转发，主要在函数模板中使用。


它的实现主要使用模板特化和引用折叠特性，一般如下所示：


template <class T>
T&& forward(typename std::remove_reference<T>::type& param) noexcept {
    return static_cast<T&&>(param);
}

template <class T>
T&& forward(typename std::remove_reference<T>::type&& param) noexcept {
    static_assert(!std::is_lvalue_reference<T>::value, "bad forward call");
    return static_cast<T&&>(param);
}

上述代码中，std::remove_reference<T>::type用于去掉类型T的引用，返回裸类型。


这里的两个forward函数模板，根据不同的参数类型，进行模板特化。第一个版本用于处理左值引用，第二个版本用于处理右值引用。两者都通过static_cast<T&&>实现类型的转换，并返回转换后的引用。


noexcept 是 C++11 引入的新特性，表示该函数保证不会抛出异常。static_assert 对编译期进行断言检查。


要理解std::forward的运作原理，需要理解引用折叠、类型萃取和模板特化等一些高级的C++特性。


///------------------引用折叠 ------------------------------------
在 C++11 中，引入了一个新的特性叫做引用折叠规则，也常常被称为"右值引用折叠规则"。这个规则是为了处理在模板和 typedef 中出现的引用的引用的情况。


引用折叠规则可以简单概括为：当出现引用的引用时，除了右值引用的右值引用外，其它情况都会折叠成左值引用。


引用折叠的规则可以用以下四个规则表示：



T& & 会折叠成 T&

T& && 会折叠成 T&

T&& & 会折叠成 T&

T&& && 会折叠成 T&&


具体来说，如果 T 是一个左值参考，T&& 就会变成一个左值引用。如果 T 是一个右值类型，那么 T&& 就是右值引用。


引用折叠规则尤其在模板和类型别名中起到重要的作用，例如在 std::forward 函数中之所以能实现完美转发就得益于这个引用折叠特性。


template <typename T>
void foo(T&& t) {
   //...
   bar(std::forward<T>(t));
 }

在上述代码中，std::forward<T>(t)会根据 t 的实际类型进行引用折叠，从而实现对 t 的完美转发。


///------------------t 的类型可能有哪些 ------------------------------------
在万能引用（通用引用）中，t的类型一般有两种可能性：左值引用（左值）和右值引用（右值）。



左值引用：常规的对象，可以对其进行赋值，取地址，有名字。如：


int i = 42;
int& ref = i;

i 和 ref 都是左值。



右值引用：一般表示对象值不需要再被使用的地方，可能相当快就会被销毁，只能移动（不能拷贝）。右值一般没有名字，不能对其取地址。如：


int&& rval = std::move(i);

rval 可以接收一个右值。


一般来说，函数返回临时对象或 prvalue（表达式结果是右值）均为右值，普通的函数参数或局部变量等为左值。


当我们在使用模板函数时，如：


template <typename T>
void foo(T&& t) {
     // ...
}

如果对 foo 函数进行如下调用：


foo(i);  // i 是左值
foo(42); // 42 是右值

在第一次调用 foo 函数时，参数 t 是左值引用；在第二次调用 foo 函数时，参数 t 是右值引用，T 的类型会相应地调整。


当然以上只是常规理解，如果我们使用std::move，可以把左值强制转化为右值。如果希望传递原始类型信息，可以使用 std::forward 进行类型的完美转发


///------------------上面的引用折叠中static_cast<T&&>(param);为什么是T&&------------------------------------
引用折叠就是在编译阶段发生的，结合静态转换（static_cast<T&&>）可以实现完美转发。T&& 在这里是对传入参数进行了重新封装，我们可以理解为一种标记方法，将实参的类型是否为左值还是右值依附在 T&& 上面，然后通过 static_cast<T&&>(param) 去转发到对应的函数上，使之匹配对应的函数（左值引用函数还是右值引用函数）。


因此，T&& 可以进行转发，它可以精确地保留原来参数的类型信息，配合 std::forward 实现完美转发的效果。如果这里不是 T&& 而是其它的类型，就无法实现这样的效果。例如，如果是 T&，那么右值就无法进行转发了；如果是 T，那么就无法保留左值的属性；如果是 const T&，那么非 const 左值就无法转发了。


因此，这里用 T&& 是最合适的，它兼顾了左值、右值和 const 的情况，能实现真正意义上的“完美转发”。


以上解释可能较为抽象，实际编程中，用一个例子去理解可能会更直观：


template<typename T>
void Func(T&& t){}

int main()
{
   int a = 0;
   Func(a);    // 此处调用的 Func 把 a当成左值来处理
   Func(42);   // 此处调用的 Func 把 42 当成右值来处理
   return 0;
}

在上述代码中，T&& 就是一个万能引用，它能接受任何类型的参数，保留它原有的性质。 通过 static_cast<T&&>，我们就可以把 t 当作右值进行处理，如此就实现了所有类型参数都适用的函数。


///------------------T&& forward(typename std::remove_reference::type&& param)  函数参数是万能引用吗？------------------------------------
不完全正确。实际上，std::forward中的这个函数的参数 std::remove_reference<T>::type&& param 并不是万能引用，但它确实与引用折叠和模板参数的类型推导有关。


当你看到 T&& 的形式时，它有可能表示万能引用，也有可能表示右值引用，关键在于 T 的类型是怎么确定的。如果 T 是模板参数，且这个类型是由编译器在模板实例化时推导得出的，那么 T&& 就是万能引用。而如果 T 的类型是明确指定的，那么 T&& 就表示右值引用。


比如我们看以下代码：


template<typename T> void foo(T&& param); // 此处的 T&& 是万能引用
int x = 27;
foo(x); // T 推导为 int&，然后 T&& 为 int& 的引用，根据引用折叠规则，此处 T&& 表示 int&

而针对 std::forward：


template<class T>
T&& forward(typename std::remove_reference<T>::type&& param) noexcept;

这里的 T 是之前已经确定的，是调用者指定的参数。本质上 std::remove_reference<T>::type&& param 是在保证输入的参数一律视为右值的情况下（type&&），再通过引用折叠（T&& forward(...) ）重新恢复其原本的性质（到底是左值还是右值），这样就能实现完美转发。


所以，尽管 std::forward 中有 T&& 这样的形式，但它并不是万能引用，也没有发生类型的推导，而是利用了右值引用和引用折叠的规则。